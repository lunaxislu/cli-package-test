{"version":3,"sources":["../src/index.ts","../src/command/init.ts","../src/util/get-project-info.ts","../src/util/get-package-info.ts"],"sourcesContent":["#!/usr/bin/env node\r\n\r\nimport { Command } from \"commander\";\r\nimport { init } from \"./command/init\";\r\n\r\nasync function main() {\r\n  const program = new Command();\r\n  program.name(\"ts-morph-test\");\r\n\r\n  program.addCommand(init);\r\n  program.parse();\r\n}\r\n\r\nmain();\r\n","import { Command } from \"commander\";\r\nimport {\r\n  getProjectInfo,\r\n  getTailwindConfigFile,\r\n  getTailwindCssFile,\r\n  updateWithFsToTailwindConfig,\r\n  updateWithTsmorphToTailwindConfig,\r\n} from \"../util/get-project-info\";\r\n\r\nexport const init = new Command().name(\"init\").action(async () => {\r\n  const cwd = process.cwd();\r\n  //   const files = await getFiles(cwd); //fast-globe lib\r\n  //   const pathResolve = await isTypeScriptProject(cwd); // fs-extra - pathExists method\r\n  //   const tsConfig = await getTsConfig(); // fs-extra - readJSON method\r\n  //   const tailwindPath = await getTailwindConfigFile(cwd);\r\n  //   let resolveTailwindPath;\r\n\r\n  //   if (tailwindPath) {\r\n  //     resolveTailwindPath = path.resolve(cwd, tailwindPath);\r\n  //     console.log(\"üöÄ ~ init ~ tailwindFile:\", resolveTailwindPath);\r\n\r\n  //   const projectInfo = await getProjectInfo(cwd);\r\n\r\n  const filePath = await getTailwindConfigFile(cwd);\r\n  if (filePath) {\r\n    const res = await updateWithFsToTailwindConfig(filePath);\r\n    await updateWithTsmorphToTailwindConfig(filePath);\r\n  }\r\n});\r\n","import path from \"path\";\r\nimport fs, { pathExists } from \"fs-extra\";\r\nimport fg from \"fast-glob\";\r\nimport { getPackageManager } from \"./get-package-info\";\r\nimport { Framework, FRAMEWORKS } from \"./framwork\";\r\nimport { JsonValue } from \"type-fest\";\r\nimport {\r\n  Node,\r\n  ObjectLiteralExpression,\r\n  Project,\r\n  QuoteKind,\r\n  SourceFile,\r\n  SyntaxKind,\r\n} from \"ts-morph\";\r\n\r\nconst PROJECT_SHARED_IGNORE = [\r\n  \"**/node_modules/**\",\r\n  \".next\",\r\n  \"public\",\r\n  \"dist\",\r\n  \"build\",\r\n];\r\nexport type ProjectType = {\r\n  framework: Framework;\r\n  isUsingAppDir: boolean;\r\n  isSrcDir: boolean;\r\n  isTsx: boolean;\r\n  configFiles: string[];\r\n  packageManager: JsonValue;\r\n};\r\nexport async function getProjectInfo(cwd: string) {\r\n  const [isSrcDir, isTsx, configFiles, packageManager] = await Promise.all([\r\n    fs.pathExists(path.resolve(cwd, \"src\")),\r\n    isTypeScriptProject(cwd),\r\n    fg.glob(\"next.config.*\", {\r\n      cwd,\r\n      deep: 1,\r\n    }),\r\n    getPackageManager(cwd),\r\n  ]);\r\n\r\n  const isNext = configFiles.length > 0; // fgÎ°ú pattern Ï∞æÏúºÎ©¥ [] ÏïàÏóê Îì§Ïñ¥Ïò§Í∏∞Ïóê\r\n\r\n  const projectType: ProjectType = {\r\n    framework: FRAMEWORKS[\"react.js\"],\r\n    isUsingAppDir: false,\r\n    isSrcDir,\r\n    isTsx,\r\n    configFiles,\r\n    packageManager,\r\n  };\r\n\r\n  if (isNext) {\r\n    projectType.isUsingAppDir = await fs.pathExists(\r\n      path.resolve(cwd, `${isSrcDir ? \"src/\" : \"\"}app`),\r\n    );\r\n    projectType.framework = projectType.isUsingAppDir\r\n      ? FRAMEWORKS[\"next-app\"]\r\n      : FRAMEWORKS[\"next-pages\"];\r\n  }\r\n  const tailwindConfigFile = await getTailwindConfigFile(cwd);\r\n  const resolveConfig = {\r\n    ...projectType,\r\n    ...projectType.framework,\r\n    tailwindConfigFile,\r\n  };\r\n\r\n  return resolveConfig;\r\n}\r\n\r\nexport async function getFiles(cwd: string) {\r\n  const files = await fg.glob(\"**/*\", {\r\n    cwd,\r\n    deep: 2,\r\n    ignore: PROJECT_SHARED_IGNORE,\r\n  });\r\n  /**\r\n   * \r\n   * deep :3 Ïùº Îïå\r\n   * [\r\n  'package.json',\r\n  'pnpm-lock.yaml',\r\n  'tsconfig.json',\r\n  'tsup.config.ts',\r\n  'src/index.ts',\r\n  'src/command/init.ts',\r\n  'src/util/get-project-info.ts',\r\n  'src/util/resolve-path.ts'\r\n]\r\n\r\n  deep: 1Ïùº Îïå \r\n  [ 'package.json', 'pnpm-lock.yaml', 'tsconfig.json', 'tsup.config.ts' ] \r\n\r\n  deep: 2Ïùº Îïå\r\n   [\r\n  'package.json',\r\n  'pnpm-lock.yaml',\r\n  'tsconfig.json',\r\n  'tsup.config.ts',\r\n  'src/index.ts'\r\n]\r\n\r\n */\r\n  return files;\r\n}\r\n\r\n//typescript ÌîÑÎ°úÏ†ùÌä∏Ïù∏ÏßÄ\r\nexport async function isTypeScriptProject(cwd: string) {\r\n  // Check if cwd has a tsconfig.json file.\r\n  return pathExists(path.resolve(cwd, \"tsconfig.json\"));\r\n}\r\n\r\n// tsconfig Í∞ÄÏ†∏Ïò§Í∏∞\r\nexport async function getTsConfig() {\r\n  try {\r\n    const tsconfigPath = path.join(\"tsconfig.json\");\r\n    const tsconfig = await fs.readJSON(tsconfigPath);\r\n\r\n    if (!tsconfig) {\r\n      throw new Error(\"tsconfig.json is missing\");\r\n    }\r\n    0;\r\n    return tsconfig;\r\n  } catch (error) {\r\n    return null;\r\n  }\r\n}\r\n\r\n// tailwindconfig ÌååÏùº Ïù¥Î¶Ñ Í∞ÄÏ†∏Ïò§Í∏∞\r\nexport async function getTailwindConfigFile(cwd: string) {\r\n  const files = await fg.glob(\"tailwind.config.*\", {\r\n    cwd,\r\n    deep: 3,\r\n    ignore: PROJECT_SHARED_IGNORE,\r\n  });\r\n  if (!files.length) {\r\n    return null;\r\n  }\r\n  // ÌååÏùº Í≤ΩÎ°ú ÏÉùÏÑ±\r\n  const filePath = path.join(cwd, files[0]);\r\n  return filePath;\r\n}\r\n\r\nexport async function getTailwindCssFile(cwd: string) {\r\n  const files = await fg.glob(\"**/*.css\", {\r\n    cwd,\r\n    deep: 5,\r\n    ignore: PROJECT_SHARED_IGNORE,\r\n  });\r\n\r\n  if (!files.length) {\r\n    return null;\r\n  }\r\n  /**\r\n   * @explain\r\n   * index.css , global.css, app.css Ïóê @tailwindBaseÎ∂ôÏó¨ÎèÑ Î¨¥Í¥Ä\r\n   * tailwind.config.* content ÏÑ§Ï†ï Ìï¥Ï§òÏïºÏßÄ Íµ¥Îü¨Í∞ê\r\n   */\r\n  for (const file of files) {\r\n    const contents = await fs.readFile(path.resolve(cwd, file), \"utf8\");\r\n    if (contents.includes(\"@tailwind base\")) {\r\n      return file;\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nexport async function updateWithFsToTailwindConfig(filepath: string) {\r\n  try {\r\n    let content = await fs.readFile(filepath, \"utf-8\");\r\n    // content Î∞∞Ïó¥ Î∂ÄÎ∂ÑÏùÑ Ï∞æÍ≥† ÏàòÏ†ïÌï† ÎÇ¥Ïö© Ï∂îÍ∞Ä\r\n    const newContent =\r\n      `\"./pages/**/*.{js,ts,jsx,tsx,mdx}\",\\n` +\r\n      `\"./components/**/*.{js,ts,jsx,tsx,mdx}\",\\n` +\r\n      `\"./app/**/*.{js,ts,jsx,tsx,mdx}\"`;\r\n\r\n    // content: [] Î∂ÄÎ∂ÑÏùÑ Ï∞æÏïÑÏÑú ÏÉàÎ°úÏö¥ Í≤ΩÎ°úÎ•º Ï∂îÍ∞Ä\r\n    content = content.replace(\"content: [],\", `content: [\\n${newContent}\\n],`);\r\n\r\n    // ÏàòÏ†ïÎêú ÎÇ¥Ïö©ÏùÑ Îã§Ïãú ÌååÏùºÏóê Ï†ÄÏû•\r\n    await fs.writeFile(filepath, content, \"utf8\");\r\n    console.log(\"Tailwind config updated successfully!\");\r\n  } catch (err) {\r\n    console.log(err);\r\n  }\r\n}\r\n\r\nexport async function updateWithTsmorphToTailwindConfig(filepath: string) {\r\n  try {\r\n    const project = new Project();\r\n\r\n    const sourceFile = project.addSourceFileAtPath(filepath);\r\n    // text\r\n    // console.log(\"File TEXT:\\n\", sourceFile.getFullText())\r\n    // ÌååÏùºÏùò Ï†ÑÏ≤¥ ÎÇ¥Ïö©ÏùÑ Í∞ùÏ≤¥Ìôî(Íµ¨Î¨∏ Ìä∏Î¶¨ ÏÉùÏÑ±)\r\n    // console.log(\"File Contents as AST:\\n\", sourceFile.getStructure());\r\n    const configObject = sourceFile\r\n      .getDescendantsOfKind(SyntaxKind.ObjectLiteralExpression)\r\n      .find((node) =>\r\n        node\r\n          .getProperties()\r\n          .some(\r\n            (property) =>\r\n              property.isKind(SyntaxKind.PropertyAssignment) &&\r\n              property.getName() === \"content\",\r\n          ),\r\n      );\r\n    // ÌååÏùºÏóêÏÑú Î™®Îì† ObjectLiteralExpression(Í∞ùÏ≤¥ Î¶¨ÌÑ∞Îü¥)ÏùÑ Ï∞æÍ∏∞\r\n    const objectLiterals = sourceFile.getDescendantsOfKind(\r\n      SyntaxKind.ObjectLiteralExpression,\r\n    );\r\n\r\n    objectLiterals.forEach((obj) => {\r\n      console.log(\"Found object literal:\", obj.getText());\r\n    });\r\n  } catch (err) {}\r\n}\r\n\r\n// Îî∞Ïò¥Ìëú Ï¢ÖÎ•òÎ•º ÌôïÏù∏ÌïòÎäî Ïú†Ìã∏Î¶¨Ìã∞ Ìï®Ïàò\r\nfunction _getQuoteChar(configObject: ObjectLiteralExpression) {\r\n  return configObject\r\n    .getFirstDescendantByKind(SyntaxKind.StringLiteral)\r\n    ?.getQuoteKind() === QuoteKind.Single\r\n    ? \"'\"\r\n    : '\"';\r\n}\r\n","import path from \"path\";\r\nimport fs from \"fs-extra\";\r\nimport { type PackageJson } from \"type-fest\";\r\nexport async function getPackageManager(cwd: string): Promise<PackageJson> {\r\n  const packageJsonPath = path.join(cwd, \"package.json\");\r\n  return fs.readJSON(packageJsonPath);\r\n}\r\n"],"mappings":";AAEA,OAAS,WAAAA,MAAe,YCFxB,OAAS,WAAAC,MAAe,YCAxB,OAAOC,MAAU,OACjB,OAAOC,GAAM,cAAAC,MAAkB,WAC/B,OAAOC,MAAQ,YCDf,OAAOC,MAAQ,WDKf,OAGE,WAAAC,EACA,aAAAC,EAEA,cAAAC,MACK,WAEP,IAAMC,EAAwB,CAC5B,qBACA,QACA,SACA,OACA,OACF,EA4GA,eAAsBC,EAAsBC,EAAa,CACvD,IAAMC,EAAQ,MAAMC,EAAG,KAAK,oBAAqB,CAC/C,IAAAF,EACA,KAAM,EACN,OAAQG,CACV,CAAC,EACD,OAAKF,EAAM,OAIMG,EAAK,KAAKJ,EAAKC,EAAM,CAAC,CAAC,EAH/B,IAKX,CA2BA,eAAsBI,EAA6BC,EAAkB,CACnE,GAAI,CACF,IAAIC,EAAU,MAAMC,EAAG,SAASF,EAAU,OAAO,EAQjDC,EAAUA,EAAQ,QAAQ,eAAgB;AAAA;AAAA;AAAA;AAAA,GAA+B,EAGzE,MAAMC,EAAG,UAAUF,EAAUC,EAAS,MAAM,EAC5C,QAAQ,IAAI,uCAAuC,CACrD,OAASE,EAAK,CACZ,QAAQ,IAAIA,CAAG,CACjB,CACF,CAEA,eAAsBC,EAAkCJ,EAAkB,CACxE,GAAI,CAGF,IAAMK,EAFU,IAAIC,EAAQ,EAED,oBAAoBN,CAAQ,EAKjDO,EAAeF,EAClB,qBAAqBG,EAAW,uBAAuB,EACvD,KAAMC,GACLA,EACG,cAAc,EACd,KACEC,GACCA,EAAS,OAAOF,EAAW,kBAAkB,GAC7CE,EAAS,QAAQ,IAAM,SAC3B,CACJ,EAEqBL,EAAW,qBAChCG,EAAW,uBACb,EAEe,QAASG,GAAQ,CAC9B,QAAQ,IAAI,wBAAyBA,EAAI,QAAQ,CAAC,CACpD,CAAC,CACH,MAAc,CAAC,CACjB,CDhNO,IAAMC,EAAO,IAAIC,EAAQ,EAAE,KAAK,MAAM,EAAE,OAAO,SAAY,CAChE,IAAMC,EAAM,QAAQ,IAAI,EAalBC,EAAW,MAAMC,EAAsBF,CAAG,EAChD,GAAIC,EAAU,CACZ,IAAME,EAAM,MAAMC,EAA6BH,CAAQ,EACvD,MAAMI,EAAkCJ,CAAQ,CAClD,CACF,CAAC,EDvBD,eAAeK,GAAO,CACpB,IAAMC,EAAU,IAAIC,EACpBD,EAAQ,KAAK,eAAe,EAE5BA,EAAQ,WAAWE,CAAI,EACvBF,EAAQ,MAAM,CAChB,CAEAD,EAAK","names":["Command","Command","path","fs","pathExists","fg","fs","Project","QuoteKind","SyntaxKind","PROJECT_SHARED_IGNORE","getTailwindConfigFile","cwd","files","fg","PROJECT_SHARED_IGNORE","path","updateWithFsToTailwindConfig","filepath","content","fs","err","updateWithTsmorphToTailwindConfig","sourceFile","Project","configObject","SyntaxKind","node","property","obj","init","Command","cwd","filePath","getTailwindConfigFile","res","updateWithFsToTailwindConfig","updateWithTsmorphToTailwindConfig","main","program","Command","init"]}